declare var _: Underscore;

declare interface Underscore
{
    (obj): UnderscoreChain;
    chain(obj): UnderscoreChain;

    each(list, iterator: (any) => void, context? );
    forEach(list, iterator: (any) => void, context? );
    map(list, iterator: (any) => any, context? ): any[];
    collect(list, iterator: (any) => any, context? ): any[];
    reduce(list, iterator: (memo, value, index? , list? ) => any, memo, context? ): any;
    inject(list, iterator: (memo, value, index?, list?) => any, memo, context? ): any;
    foldl(list, iterator: (memo, value, index?, list?) => any, memo, context? ): any;
    reduceRight(list, iterator: (memo, value, index?, list?) => any, memo, context? ): any;
    foldr(list, iterator: (memo, value, index?, list?) => any, memo, context? ): any;
    find(list, iterator: (any) => bool, context? ): any;
    detect(list, iterator: (any) => bool, context? ): any;
    filter(list, iterator: (any) => bool, context? ): any[];
    select(list, iterator: (any) => bool, context? ): any[];
    where(list, properties: { }): any[];
    reject(list, iterator: (any) => bool, context? ): any[];
    all(list, iterator: (any) => bool, context? ): bool;
    every(list, iterator: (any) => bool, context? ): bool;
    any(list, iterator?: (any) => bool , context? ): bool;
    some(list, iterator?: (any) => bool , context? ): bool;
    contains(list, value): bool;
    include(list, value): bool;
    invoke(list, methodName: string, ...arguments: any[]): any;
    pluck(list, propertyName: string): any[];
    max(list, iterator?: (any) => any, context? ): any;
    min(list, iterator?: (any) => any , context? ): any;
    sortBy(list, iterator: (any) => any, context? ): any[];
    groupBy(list, iterator: (any) => any): any;
    groupBy(list, iterator: string): any;
    countBy(list, iterator: (any) => any): { [group: any]: number; };
    countBy(list, iterator: string): { [group: any]: number; };
    shuffle(list): any[];
    toArray(list): any[];
    size(list): number;

    first(array: any[]): any;
    head(array: any[]): any;
    take(array: any[]): any;
    first(array: any[], n: number ): any[];
    head(array: any[], n: number ): any[];
    take(array: any[], n: number ): any[];
    initial(array: any[], n?: number ): any[];
    last(array: any[], n?: number ): any[];
    rest(array: any[], index?: number ): any[];
    tail(array: any[], index?: number ): any[];
    drop(array: any[], index?: number ): any[];
    compact(array: any[]): any[];
    flatten(array: any[], shallow?: bool ): any[];
    without(array: any[], ...values: any[]): any[];
    union(...arrays: any[][]): any[];
    intersection(...arrays: any[][]): any[];
    difference(array: any[], ...others: any[]): any[];
    uniq(array: any[], isSorted? , iterator? ): any[];
    unique(array: any[], isSorted? , iterator? ): any[];
    zip(...arrays: any[][]): any[];
    object(list: any[][]): { };
    object(list: any[], values: any[] ): { };
    indexOf(array: any[], value, isSorted?: bool ): number;
    lastIndexOf(array: any[], value, fromIndex?: number ): number;
    sortedIndex(list, value, iterator?: (any) => any): number;
    range(stop: number): number[];
    range(start: number, stop: number, step?: number): number[];

    bind(fct: Function, object: any, ...arguments: any[]): Function;
    bindAll(object: any, ...methodNames: string[]);
    memoize(fct: Function, hashFunction: Function ): Function;
    delay(fct: Function, wait: number, ...arguments: any[]): void;
    defer(fct: Function, ...arguments: any[]): void;
    throttle(fct: Function, wait: number): Function;
    debounce(fct: Function, wait: number, immediate? ): Function;
    once(fct: Function): Function;
    after(count: number, fct: Function): Function;
    wrap(fct: Function, wrapper: Function): Function;
    compose(...functions: Function[]): Function;

    keys(object: { }): string[];
    values(object: { }): any[];
    pairs(object: { }): any[][];
    invert(object: { }): { };
    functions(object: { }): string[];
    methods(object: { }): string[];
    extend(destination: { }, ...args: { }[]): { };
    pick(object: { }, ...keys: string[]): { };
    omit(object: { }, ...keys: string[]): { };
    defaults(object: { }, ...defaults: any[]): { };
    clone(object: { }): { };
    tap(object: { }, interceptor: (o: { }) => void ): { };
    has(object: { }, key: string): bool;
    isEqual(object, other): bool;
    isEmpty(object): bool;
    isElement(object): bool;
    isArray(object): bool;
    isObject(value): bool;
    isArguments(object): bool;
    isFunction(object): bool;
    isString(object): bool;
    isNumber(object): bool;
    isFinite(object): bool;
    isBoolean(object): bool;
    isDate(object): bool;
    isRegExp(object): bool;
    isNaN(object): bool;
    isNull(object): bool;
    isUndefined(value): bool;

    noConflict() : Underscore;
    identity(value): any;
    times(n: number, iterator: (index: number) => void , context? ): void;
    random(min: number, max: number): number;
    mixin(object);
    uniqueId(prefix?: string ): any;
    escape(string): string;
    result(object, property: any): any;
    template(templateString: string, data?: { }, settings?: { } ): Function;
}

declare interface UnderscoreChain
{
    value(): any;

    each(iterator: (any) => void, context? ) : UnderscoreChain;
    forEach(iterator: (any) => void, context? ) : UnderscoreChain;
    map(iterator: (any) => any, context? ) : UnderscoreChain;
    collect(iterator: (any) => any, context? ) : UnderscoreChain;
    reduce(iterator: (memo, value, index?, list?) => any, memo, context? ) : UnderscoreChain;
    inject(iterator: (memo, value, index?, list?) => any, memo, context? ) : UnderscoreChain;
    foldl(iterator: (memo, value, index?, list?) => any, memo, context? ) : UnderscoreChain;
    reduceRight(iterator: (memo, value, index?, list?) => any, memo, context? ) : UnderscoreChain;
    foldr(iterator: (memo, value, index?, list?) => any, memo, context? ) : UnderscoreChain;
    find(iterator: (any) => bool, context? ) : UnderscoreChain;
    detect(iterator: (any) => bool, context? ) : UnderscoreChain;
    filter(iterator: (any) => bool, context? ) : UnderscoreChain;
    select(iterator: (any) => bool, context? ) : UnderscoreChain;
    where(properties: { }) : UnderscoreChain;
    reject(iterator: (any) => bool, context? ) : UnderscoreChain;
    all(iterator: (any) => bool, context? ) : UnderscoreChain;
    every(iterator: (any) => bool, context? ) : UnderscoreChain;
    any(iterator?: (any) => bool , context? ) : UnderscoreChain;
    some(iterator?: (any) => bool , context? ) : UnderscoreChain;
    contains(value) : UnderscoreChain;
    include(value) : UnderscoreChain;
    invoke(methodName: string, ...arguments: any[]) : UnderscoreChain;
    pluck(propertyName: string) : UnderscoreChain;
    max(iterator?: (any) => any, context? ) : UnderscoreChain;
    min(iterator?: (any) => any , context? ) : UnderscoreChain;
    sortBy(iterator: (any) => any, context? ) : UnderscoreChain;
    groupBy(iterator: (any) => any) : UnderscoreChain;
    groupBy(iterator: string) : UnderscoreChain;
    countBy(iterator: (any) => any) : UnderscoreChain;
    countBy(iterator: string) : UnderscoreChain;
    shuffle() : UnderscoreChain;
    toArray() : UnderscoreChain;
    size() : UnderscoreChain;

    first(): UnderscoreChain;
    head(): UnderscoreChain;
    take(): UnderscoreChain;
    first(n: number ): UnderscoreChain;
    head(n: number ): UnderscoreChain;
    take(n: number ): UnderscoreChain;
    initial(n?: number ): UnderscoreChain;
    last(n?: number ): UnderscoreChain;
    rest(index?: number ): UnderscoreChain;
    tail(index?: number ): UnderscoreChain;
    drop(index?: number ): UnderscoreChain;
    compact(): UnderscoreChain;
    flatten(shallow?: bool ): UnderscoreChain;
    without(...values: any[]): UnderscoreChain;
    union(...arrays: any[][]): UnderscoreChain;
    intersection(...arrays: any[][]): UnderscoreChain;
    difference(...others: any[]): UnderscoreChain;
    uniq(isSorted? , iterator? ): UnderscoreChain;
    unique(isSorted? , iterator? ): UnderscoreChain;
    zip(...arrays: any[][]): UnderscoreChain;
    object(values: any[] ): UnderscoreChain;
    indexOf(value, isSorted?: bool ) : UnderscoreChain;
    lastIndexOf(value, fromIndex?: number ) : UnderscoreChain;
    sortedIndex(value, iterator?: (any) => any) : UnderscoreChain;
    range() : UnderscoreChain;

    bind(object: { }, ...arguments: any[]): UnderscoreChain;
    bindAll(object: { }, ...methodNames: string[]);
    memoize(hashFunction: Function ): UnderscoreChain;
    delay(wait: number, ...arguments: any[]): void;
    defer(...arguments: any[]): void;
    throttle(wait: number): UnderscoreChain;
    debounce(wait: number, immediate? ): UnderscoreChain;
    once(fct: Function): UnderscoreChain;
    after(count: number, fct: Function): UnderscoreChain;
    wrap(wrapper: Function): UnderscoreChain;
    compose(...functions: Function[]): UnderscoreChain;

    keys(): UnderscoreChain;
    values(): UnderscoreChain;
    pairs(): UnderscoreChain;
    invert(): UnderscoreChain;
    functions(): UnderscoreChain;
    methods(): UnderscoreChain;
    extend(destination: { }, ): UnderscoreChain;
    pick(...keys: string[]): UnderscoreChain;
    omit(...keys: string[]): UnderscoreChain;
    defaults(...defaults: any[]): UnderscoreChain;
    clone(): UnderscoreChain;
    tap(interceptor: (o: { }) => void ): UnderscoreChain;
    has(key: string): UnderscoreChain;
    isEqual(other): UnderscoreChain;
    isEmpty(): UnderscoreChain;
    isElement(): UnderscoreChain;
    isArray(): UnderscoreChain;
    isObject(value): UnderscoreChain;
    isArguments(): UnderscoreChain;
    isFunction(): UnderscoreChain;
    isString(): UnderscoreChain;
    isNumber(): UnderscoreChain;
    isFinite(): UnderscoreChain;
    isBoolean(): UnderscoreChain;
    isDate(): UnderscoreChain;
    isRegExp(): UnderscoreChain;
    isNaN(): UnderscoreChain;
    isNull(): UnderscoreChain;
    isUndefined(value): UnderscoreChain;

    times(iterator: (index: number) => void , context? ): void;
    escape(): UnderscoreChain;
    result(property: string): UnderscoreChain;
}

